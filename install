#!/usr/bin/env bash

CLASHTUI_CONFIG_DIR=${XDG_CONFIG_HOME:-$HOME/.config}/clashtui
CLASHTUI_INSTALL_DIR=/opt/clashtui
INSTALL_RES_URL_PREFIX=https://raw.githubusercontent.com/JohanChane/clashtui/refs/heads/main/InstallRes

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
  echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
  echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
  echo -e "${RED}[ERROR]${NC} $1" >&2
}

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

create_mihomo_user() {
  if ! id "mihomo" &>/dev/null; then
    log_info "Creating mihomo user and group..."
    sudo groupadd --system mihomo
    sudo useradd --system --no-create-home --gid mihomo --shell /bin/false mihomo
  else
    log_info "mihomo user already exists"
  fi
}

create_mihomo_systemd_unit() {
  log_info "Creating mihomo systemd unit..."

  sudo tee "$CLASHTUI_INSTALL_DIR/clashtui_mihomo.service" >/dev/null <<'EOF'
[Unit]
Description=mihomo Daemon, Another Clash Kernel.
After=network.target NetworkManager.service systemd-networkd.service iwd.service

[Service]
Type=simple
User=mihomo
Group=mihomo
LimitNPROC=500
LimitNOFILE=1000000
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCH CAP_DAC_OVERRIDE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCH CAP_DAC_OVERRIDE
Restart=always
ExecStartPre=/usr/bin/sleep 1s
ExecStart=/opt/clashtui/mihomo -d /opt/clashtui/mihomo_config
ExecReload=/bin/kill -HUP $MAINPID

[Install]
WantedBy=multi-user.target
EOF

  sudo ln -s $CLASHTUI_INSTALL_DIR/clashtui_mihomo.service /etc/systemd/system/
  sudo systemctl daemon-reload
}

create_clashtui_config() {
  log_info "Creating clashtui config.yaml..."

  # backup config.yaml
  if [ -f "$CLASHTUI_CONFIG_DIR/config.yaml" ]; then
    cp -f "$CLASHTUI_CONFIG_DIR/config.yaml" "$CLASHTUI_CONFIG_DIR/config.yaml.old"
  fi

  tee "$CLASHTUI_CONFIG_DIR/config.yaml" >/dev/null <<'EOF'
basic:
  clash_config_dir: '/opt/clashtui/mihomo_config'
  clash_bin_path: '/opt/clashtui/mihomo'
  clash_config_path: '/opt/clashtui/mihomo_config/config.yaml'
  timeout: null
service:
  clash_srv_name: 'clashtui_mihomo'
  is_user: false
extra:
  edit_cmd:
  open_dir_cmd:
EOF

  echo -n "Do you want to download basic_clash_config.yaml? (y/N): "
  read -r response
  if [ "$response" = "y" ] || [ "$response" = "Y" ]; then
    log_info "Downloading basic_clash_config.yaml..."
    curl -o $CLASHTUI_CONFIG_DIR/basic_clash_config.yaml $INSTALL_RES_URL_PREFIX/basic_clash_config.yaml
  elif [ ! -f "$CLASHTUI_CONFIG_DIR/basic_clash_config.yaml" ]; then
    tee "$CLASHTUI_CONFIG_DIR/basic_clash_config.yaml" >/dev/null <<'EOF'
mixed-port: 7890
mode: rule
log-level: info
external-controller: 127.0.0.1:9090
EOF
  fi

  sudo cp "$CLASHTUI_CONFIG_DIR/basic_clash_config.yaml" "$CLASHTUI_INSTALL_DIR/mihomo_config/config.yaml"

  mkdir "$CLASHTUI_CONFIG_DIR/profiles"
  mkdir "$CLASHTUI_CONFIG_DIR/templates"
  local template_proxy_providers_path
  template_proxy_providers_path="$CLASHTUI_CONFIG_DIR/templates/template_proxy_providers"
  if [ ! -f "$template_proxy_providers_path" ]; then
    tee "$template_proxy_providers_path" >/dev/null <<'EOF'
# This is a comment
# Place each subscription on a separate line
EOF
  fi

  echo -n "Do you want to download templates? (y/N): "
  read -r response
  if [ "$response" = "y" ] || [ "$response" = "Y" ]; then
    log_info "Downloading templates..."
    curl -o $CLASHTUI_CONFIG_DIR/templates/common_tpl.yaml $INSTALL_RES_URL_PREFIX/templates/common_tpl.yaml
    curl -o $CLASHTUI_CONFIG_DIR/templates/generic_tpl.yaml $INSTALL_RES_URL_PREFIX/templates/generic_tpl.yaml
    curl -o $CLASHTUI_CONFIG_DIR/templates/generic_tpl_with_all.yaml $INSTALL_RES_URL_PREFIX/templates/generic_tpl_with_all.yaml
    curl -o $CLASHTUI_CONFIG_DIR/templates/generic_tpl_with_filter.yaml $INSTALL_RES_URL_PREFIX/templates/generic_tpl_with_filter.yaml
    curl -o $CLASHTUI_CONFIG_DIR/templates/generic_tpl_with_rulest.yaml $INSTALL_RES_URL_PREFIX/templates/generic_tpl_with_ruleset.yaml
  fi
}

detect_architecture() {
  local arch
  arch=$(uname -m)

  case "$arch" in
  x86_64 | amd64)
    echo "amd64"
    ;;
  aarch64 | arm64)
    echo "arm64"
    ;;
  armv7l | armhf)
    echo "armv7"
    ;;
  armv6l)
    echo "armv6"
    ;;
  i386 | i686)
    echo "386"
    ;;
  *)
    echo "unsupported"
    ;;
  esac
}

detect_os() {
  local os
  os=$(uname -s | tr '[:upper:]' '[:lower:]')

  case "$os" in
  linux)
    echo "linux"
    ;;
  darwin)
    echo "darwin"
    ;;
  freebsd)
    echo "freebsd"
    ;;
  *)
    echo "unsupported"
    ;;
  esac
}

# Detect CPU instruction set level using /proc/cpuinfo (mask v4, maximum to v3)
detect_cpu_level_using_proc() {
  # Get CPU instruction set (flags field) from /proc/cpuinfo
  local flags=$(grep -m 1 '^flags' /proc/cpuinfo | awk '{print $0}')

  # Check if it's amd64 (x86-64) architecture (basic requirement)
  if ! echo "$flags" | grep -q ' lm '; then
    echo "" # Non-amd64 architecture, output empty
    return
  fi

  # Define instruction sets required for each level (maximum to v3)
  # x86-64-v1 basic instruction set
  local v1_required="cmov cx8 fpu fxsr mmx osfxsr sce sse sse2"
  # x86-64-v2 extended instruction set (based on v1)
  local v2_required="cx16 lahf_lm popcnt sse3 sse4_1 sse4_2 ssse3"
  # x86-64-v3 advanced instruction set (based on v2)
  local v3_required="avx avx2 bmi1 bmi2 f16c fma lzcnt movbe osxsave"
  # x86-64-v4 flagship instruction set (based on v3)
  local v4_required="avx512f avx512bw avx512cd avx512dq avx512vl"

  # Check if all instruction sets are satisfied
  local check_flags
  check_flags() {
    local required="$1"
    for flag in $required; do
      # Exact match instruction set (with spaces before and after to avoid partial matches)
      if ! echo " $flags " | grep -q " $flag "; then
        return 1
      fi
    done
    return 0
  }

  # Determine from highest level (v3 -> v2 -> v1)
  # if check_flags "$v1_required" && check_flags "$v2_required" && check_flags "$v3_required" && check_flags "$v4_required"; then
  #     echo "v4"
  # el
  if check_flags "$v1_required" && check_flags "$v2_required" && check_flags "$v3_required"; then
    echo "v3"
  elif check_flags "$v1_required" && check_flags "$v2_required"; then
    echo "v2"
  elif check_flags "$v1_required"; then
    echo "v1"
  else
    echo "" # Does not meet v1 basic requirements, output empty
  fi
}

# Detect CPU instruction set level using dynamic linker (mask v4, maximum to v3)
detect_cpu_level_using_ld() {
  local ld_path="/lib64/ld-linux-x86-64.so.2"

  # Check if the dynamic linker exists and is executable (may not exist on non-amd64 architectures)
  if [ ! -x "$ld_path" ]; then
    echo "" # Non-amd64 architecture, output empty
    return 0
  fi

  # Get levels marked with "(supported, searched)" in the dynamic linker help information
  local levels=$("$ld_path" --help 2>/dev/null | grep -oP 'x86-64-v\d+(?=.*\(supported, searched\))' | sort -u)

  # Return empty if no supported level information is found
  if [ -z "$levels" ]; then
    echo ""
    return 0
  fi

  # Find the highest supported level (maximum to v3)
  local highest_level=""
  for level in $levels; do
    case $level in
    x86-64-v3)
      highest_level="v3"
      break
      ;; # Highest level is v3
    x86-64-v2) highest_level="v2" ;;
    x86-64-v1) highest_level="v1" ;;
    x86-64-v4) highest_level="v3" ;; # Mask v4, treat as v3
    esac
  done

  echo "$highest_level"
  return 0
}

# Main function: Handle output format
detect_cpu_level() {
  # First try using the dynamic linker method
  local level=$(detect_cpu_level_using_ld)

  # Use proc method if dynamic linker method returns empty
  if [ -z "$level" ]; then
    level=$(detect_cpu_level_using_proc)
  fi

  # Handle output format: output empty if empty, add prefix - if there is a value
  if [ -n "$level" ]; then
    echo "-$level"
  else
    echo ""
  fi
}

download_mihomo() {
  # First get the base architecture value
  local base_arch=$(detect_architecture)
  # When the base architecture is amd64, concatenate the cpu_level value; otherwise, use the base architecture value directly
  local arch=$([ "$base_arch" = "amd64" ] && echo "${base_arch}$(detect_cpu_level)" || echo "$base_arch")
  local os=$(detect_os)
  local download_url
  local temp_dir=$(mktemp -d)
  local latest_version=$(curl -s "https://api.github.com/repos/MetaCubeX/mihomo/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')

  if [ "$arch" = "unsupported" ] || [ "$os" = "unsupported" ]; then
    log_error "Unsupported architecture ($(uname -m)) or OS ($(uname -s))"
    rm -rf "$temp_dir"
    return 1
  fi

  download_url="https://github.com/MetaCubeX/mihomo/releases/latest/download/mihomo-${os}-${arch}-${latest_version}.gz"

  log_info "Detected: OS=$os, Arch=$arch, LatestVersion=$latest_version, download_url=$download_url"

  curl -L "$download_url" -o "$temp_dir/mihomo.gz"
  gunzip -c "$temp_dir/mihomo.gz" >"$temp_dir/mihomo"

  local binary_path
  if [ -f "$temp_dir/mihomo" ]; then
    binary_path="$temp_dir/mihomo"
  else
    log_error "Could not find binary in the downloaded archive"
    rm -rf "$temp_dir"
    return 1
  fi

  sudo install -m 755 "$binary_path" "$CLASHTUI_INSTALL_DIR/mihomo"
  log_info "Successfully installed mihomo to: $CLASHTUI_INSTALL_DIR/mihomo"
  rm -rf "$temp_dir"
}

install_mihomo() {
  if command_exists mihomo; then
    sudo ln -s "$(which mihomo)" $CLASHTUI_INSTALL_DIR/mihomo
  elif command_exists clash-meta; then
    sudo ln -s "$(which clash-meta)" $CLASHTUI_INSTALL_DIR/mihomo
  else
    download_mihomo
  fi

  create_mihomo_user
  sudo gpasswd -a $USER mihomo

  sudo chown mihomo:mihomo "$CLASHTUI_INSTALL_DIR/mihomo_config"
  create_mihomo_systemd_unit
}

install_clashtui() {
  if ! command_exists clashtui; then
    download_clashtui
  fi

  create_clashtui_config
}

download_clashtui() {
  local arch=$(detect_architecture)
  local os=$(detect_os)
  local download_url
  local temp_dir=$(mktemp -d)
  local latest_version=$(curl -s "https://api.github.com/repos/JohanChane/clashtui/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')

  if [ "$arch" = "unsupported" ] || [ "$os" = "unsupported" ]; then
    log_error "Unsupported architecture ($(uname -m)) or OS ($(uname -s))"
    rm -rf "$temp_dir"
    return 1
  fi

  download_url="https://github.com/JohanChane/clashtui/releases/latest/download/clashtui-${os}-${arch}-${latest_version}.gz"

  log_info "Detected: OS=$os, Arch=$arch, LatestVersion=$latest_version, download_url=$download_url"

  curl -L "$download_url" -o "$temp_dir/clashtui.gz"
  gunzip -c "$temp_dir/clashtui.gz" >"$temp_dir/clashtui"

  local binary_path
  if [ -f "$temp_dir/clashtui" ]; then
    binary_path="$temp_dir/clashtui"
  else
    log_error "Could not find binary in the downloaded archive"
    rm -rf "$temp_dir"
    return 1
  fi

  sudo install -m 755 "$binary_path" "$CLASHTUI_INSTALL_DIR/clashtui"
  sudo ln -s "$CLASHTUI_INSTALL_DIR/clashtui" /usr/local/bin/clashtui
  log_info "Successfully installed clashtui to: $CLASHTUI_INSTALL_DIR/clashtui"
  rm -rf "$temp_dir"
}

uninstall() {
  echo "Please make sure the mihomo daemon has been stopped before uninstallation."
  echo -n "Continue with uninstallation? (y/N): "
  read -r response
  if [ "$response" != "y" ] && [ "$response" != "Y" ]; then
    echo "Uninstallation cancelled."
    return 1
  fi

  sudo rm -f /etc/systemd/system/clashtui_mihomo.service
  sudo systemctl daemon-reload
  sudo rm -f /usr/local/bin/clashtui
  sudo rm -rf /opt/clashtui

  echo "[Optional] Delete the mihomo user and group"
  echo "  sudo gpasswd -d $USER mihomo"
  echo "  sudo userdel mihomo"
}

show_help() {
  echo "Usage: $0 [OPTION]"
  echo "Install or uninstall clashtui"
  echo
  echo "Options:"
  echo "  -h, --help       Show this help message and exit"
  echo "  -u, --uninstall  Uninstall clashtui"
  echo
  echo "If no options are provided, the script will install clashtui."
}

main() {
  while [[ $# -gt 0 ]]; do
    case $1 in
    -u | --uninstall)
      uninstall
      return 0
      ;;
    -h | --help)
      show_help
      return 0
      ;;
    *)
      log_error "Unknown option"
      show_help
      return 1
      ;;
    esac
  done

  sudo mkdir -p "$CLASHTUI_INSTALL_DIR/mihomo_config"
  mkdir -p "$CLASHTUI_CONFIG_DIR"

  install_mihomo
  install_clashtui

  log_warn 'Please log out and log back in for the group file permissions to take effect'
}

main "$@"
